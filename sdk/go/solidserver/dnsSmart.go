// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package solidserver

import (
	"context"
	"reflect"

	"github.com/AthenaWolfe/pulumi-solidserver/sdk/go/solidserver/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// DNS SMART resource allows to create and manage DNS SMART architectures,
// SMART(s) are abstratc containers managing several DNS servers as a unique entity.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/AthenaWolfe/pulumi-solidserver/sdk/go/solidserver"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := solidserver.NewDnsSmart(ctx, "myFirstDnsSMART", &solidserver.DnsSmartArgs{
//				AllowQueries: pulumi.StringArray{
//					pulumi.String("172.16.0.0/12"),
//					pulumi.String("10.0.0.0/8"),
//					pulumi.String("192.168.0.0/24"),
//				},
//				AllowRecursions: pulumi.StringArray{
//					pulumi.String("172.16.0.0/12"),
//					pulumi.String("10.0.0.0/8"),
//					pulumi.String("192.168.0.0/24"),
//				},
//				Arch:    pulumi.String("multimaster"),
//				Comment: pulumi.String("My First DNS SMART Autmatically created"),
//				Forward: pulumi.String("first"),
//				Forwarders: pulumi.StringArray{
//					pulumi.String("10.0.0.42"),
//					pulumi.String("10.0.0.43"),
//				},
//				Recursion: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type DnsSmart struct {
	pulumi.CustomResourceState

	// A list of network prefixes allowed to query the DNS server (named ACL(s) are not supported using this provider).  Use '!' to negate an entry.
	AllowQueries pulumi.StringArrayOutput `pulumi:"allowQueries"`
	// A list of network prefixes allowed to query the DNS server for recursion (named ACL(s) are not supported using this provider).  Use '!' to negate an entry.
	AllowRecursions pulumi.StringArrayOutput `pulumi:"allowRecursions"`
	// A list of network prefixes allowed to query the DNS erver for zone transfert (named ACL(s) are not supported using this provider).  Use '!' to negate an entry.
	AllowTransfers pulumi.StringArrayOutput `pulumi:"allowTransfers"`
	// The DNS SMART architecture (Suported: multimaster, masterslave, single; Default: masterslave).
	Arch pulumi.StringPtrOutput `pulumi:"arch"`
	// The class associated to the DNS SMART.
	Class pulumi.StringPtrOutput `pulumi:"class"`
	// The class parameters associated to the DNS SMART.
	ClassParameters pulumi.StringMapOutput `pulumi:"classParameters"`
	// Custom information about the DNS SMART.
	Comment pulumi.StringPtrOutput `pulumi:"comment"`
	// The forwarding mode of the DNS SMART (Supported: none, first, only; Default: none).
	Forward pulumi.StringPtrOutput `pulumi:"forward"`
	// The IP address list of the forwarder(s) configured to configure on the DNS SMART.
	Forwarders pulumi.StringArrayOutput `pulumi:"forwarders"`
	// The name of the DNS SMART members.
	Members pulumi.StringArrayOutput `pulumi:"members"`
	// The name of the DNS SMART to create.
	Name pulumi.StringOutput `pulumi:"name"`
	// The recursion mode of the DNS SMART (Default: true).
	Recursion pulumi.BoolPtrOutput `pulumi:"recursion"`
}

// NewDnsSmart registers a new resource with the given unique name, arguments, and options.
func NewDnsSmart(ctx *pulumi.Context,
	name string, args *DnsSmartArgs, opts ...pulumi.ResourceOption) (*DnsSmart, error) {
	if args == nil {
		args = &DnsSmartArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource DnsSmart
	err := ctx.RegisterResource("solidserver:index/dnsSmart:DnsSmart", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDnsSmart gets an existing DnsSmart resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDnsSmart(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DnsSmartState, opts ...pulumi.ResourceOption) (*DnsSmart, error) {
	var resource DnsSmart
	err := ctx.ReadResource("solidserver:index/dnsSmart:DnsSmart", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering DnsSmart resources.
type dnsSmartState struct {
	// A list of network prefixes allowed to query the DNS server (named ACL(s) are not supported using this provider).  Use '!' to negate an entry.
	AllowQueries []string `pulumi:"allowQueries"`
	// A list of network prefixes allowed to query the DNS server for recursion (named ACL(s) are not supported using this provider).  Use '!' to negate an entry.
	AllowRecursions []string `pulumi:"allowRecursions"`
	// A list of network prefixes allowed to query the DNS erver for zone transfert (named ACL(s) are not supported using this provider).  Use '!' to negate an entry.
	AllowTransfers []string `pulumi:"allowTransfers"`
	// The DNS SMART architecture (Suported: multimaster, masterslave, single; Default: masterslave).
	Arch *string `pulumi:"arch"`
	// The class associated to the DNS SMART.
	Class *string `pulumi:"class"`
	// The class parameters associated to the DNS SMART.
	ClassParameters map[string]string `pulumi:"classParameters"`
	// Custom information about the DNS SMART.
	Comment *string `pulumi:"comment"`
	// The forwarding mode of the DNS SMART (Supported: none, first, only; Default: none).
	Forward *string `pulumi:"forward"`
	// The IP address list of the forwarder(s) configured to configure on the DNS SMART.
	Forwarders []string `pulumi:"forwarders"`
	// The name of the DNS SMART members.
	Members []string `pulumi:"members"`
	// The name of the DNS SMART to create.
	Name *string `pulumi:"name"`
	// The recursion mode of the DNS SMART (Default: true).
	Recursion *bool `pulumi:"recursion"`
}

type DnsSmartState struct {
	// A list of network prefixes allowed to query the DNS server (named ACL(s) are not supported using this provider).  Use '!' to negate an entry.
	AllowQueries pulumi.StringArrayInput
	// A list of network prefixes allowed to query the DNS server for recursion (named ACL(s) are not supported using this provider).  Use '!' to negate an entry.
	AllowRecursions pulumi.StringArrayInput
	// A list of network prefixes allowed to query the DNS erver for zone transfert (named ACL(s) are not supported using this provider).  Use '!' to negate an entry.
	AllowTransfers pulumi.StringArrayInput
	// The DNS SMART architecture (Suported: multimaster, masterslave, single; Default: masterslave).
	Arch pulumi.StringPtrInput
	// The class associated to the DNS SMART.
	Class pulumi.StringPtrInput
	// The class parameters associated to the DNS SMART.
	ClassParameters pulumi.StringMapInput
	// Custom information about the DNS SMART.
	Comment pulumi.StringPtrInput
	// The forwarding mode of the DNS SMART (Supported: none, first, only; Default: none).
	Forward pulumi.StringPtrInput
	// The IP address list of the forwarder(s) configured to configure on the DNS SMART.
	Forwarders pulumi.StringArrayInput
	// The name of the DNS SMART members.
	Members pulumi.StringArrayInput
	// The name of the DNS SMART to create.
	Name pulumi.StringPtrInput
	// The recursion mode of the DNS SMART (Default: true).
	Recursion pulumi.BoolPtrInput
}

func (DnsSmartState) ElementType() reflect.Type {
	return reflect.TypeOf((*dnsSmartState)(nil)).Elem()
}

type dnsSmartArgs struct {
	// A list of network prefixes allowed to query the DNS server (named ACL(s) are not supported using this provider).  Use '!' to negate an entry.
	AllowQueries []string `pulumi:"allowQueries"`
	// A list of network prefixes allowed to query the DNS server for recursion (named ACL(s) are not supported using this provider).  Use '!' to negate an entry.
	AllowRecursions []string `pulumi:"allowRecursions"`
	// A list of network prefixes allowed to query the DNS erver for zone transfert (named ACL(s) are not supported using this provider).  Use '!' to negate an entry.
	AllowTransfers []string `pulumi:"allowTransfers"`
	// The DNS SMART architecture (Suported: multimaster, masterslave, single; Default: masterslave).
	Arch *string `pulumi:"arch"`
	// The class associated to the DNS SMART.
	Class *string `pulumi:"class"`
	// The class parameters associated to the DNS SMART.
	ClassParameters map[string]string `pulumi:"classParameters"`
	// Custom information about the DNS SMART.
	Comment *string `pulumi:"comment"`
	// The forwarding mode of the DNS SMART (Supported: none, first, only; Default: none).
	Forward *string `pulumi:"forward"`
	// The IP address list of the forwarder(s) configured to configure on the DNS SMART.
	Forwarders []string `pulumi:"forwarders"`
	// The name of the DNS SMART to create.
	Name *string `pulumi:"name"`
	// The recursion mode of the DNS SMART (Default: true).
	Recursion *bool `pulumi:"recursion"`
}

// The set of arguments for constructing a DnsSmart resource.
type DnsSmartArgs struct {
	// A list of network prefixes allowed to query the DNS server (named ACL(s) are not supported using this provider).  Use '!' to negate an entry.
	AllowQueries pulumi.StringArrayInput
	// A list of network prefixes allowed to query the DNS server for recursion (named ACL(s) are not supported using this provider).  Use '!' to negate an entry.
	AllowRecursions pulumi.StringArrayInput
	// A list of network prefixes allowed to query the DNS erver for zone transfert (named ACL(s) are not supported using this provider).  Use '!' to negate an entry.
	AllowTransfers pulumi.StringArrayInput
	// The DNS SMART architecture (Suported: multimaster, masterslave, single; Default: masterslave).
	Arch pulumi.StringPtrInput
	// The class associated to the DNS SMART.
	Class pulumi.StringPtrInput
	// The class parameters associated to the DNS SMART.
	ClassParameters pulumi.StringMapInput
	// Custom information about the DNS SMART.
	Comment pulumi.StringPtrInput
	// The forwarding mode of the DNS SMART (Supported: none, first, only; Default: none).
	Forward pulumi.StringPtrInput
	// The IP address list of the forwarder(s) configured to configure on the DNS SMART.
	Forwarders pulumi.StringArrayInput
	// The name of the DNS SMART to create.
	Name pulumi.StringPtrInput
	// The recursion mode of the DNS SMART (Default: true).
	Recursion pulumi.BoolPtrInput
}

func (DnsSmartArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*dnsSmartArgs)(nil)).Elem()
}

type DnsSmartInput interface {
	pulumi.Input

	ToDnsSmartOutput() DnsSmartOutput
	ToDnsSmartOutputWithContext(ctx context.Context) DnsSmartOutput
}

func (*DnsSmart) ElementType() reflect.Type {
	return reflect.TypeOf((**DnsSmart)(nil)).Elem()
}

func (i *DnsSmart) ToDnsSmartOutput() DnsSmartOutput {
	return i.ToDnsSmartOutputWithContext(context.Background())
}

func (i *DnsSmart) ToDnsSmartOutputWithContext(ctx context.Context) DnsSmartOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DnsSmartOutput)
}

// DnsSmartArrayInput is an input type that accepts DnsSmartArray and DnsSmartArrayOutput values.
// You can construct a concrete instance of `DnsSmartArrayInput` via:
//
//	DnsSmartArray{ DnsSmartArgs{...} }
type DnsSmartArrayInput interface {
	pulumi.Input

	ToDnsSmartArrayOutput() DnsSmartArrayOutput
	ToDnsSmartArrayOutputWithContext(context.Context) DnsSmartArrayOutput
}

type DnsSmartArray []DnsSmartInput

func (DnsSmartArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DnsSmart)(nil)).Elem()
}

func (i DnsSmartArray) ToDnsSmartArrayOutput() DnsSmartArrayOutput {
	return i.ToDnsSmartArrayOutputWithContext(context.Background())
}

func (i DnsSmartArray) ToDnsSmartArrayOutputWithContext(ctx context.Context) DnsSmartArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DnsSmartArrayOutput)
}

// DnsSmartMapInput is an input type that accepts DnsSmartMap and DnsSmartMapOutput values.
// You can construct a concrete instance of `DnsSmartMapInput` via:
//
//	DnsSmartMap{ "key": DnsSmartArgs{...} }
type DnsSmartMapInput interface {
	pulumi.Input

	ToDnsSmartMapOutput() DnsSmartMapOutput
	ToDnsSmartMapOutputWithContext(context.Context) DnsSmartMapOutput
}

type DnsSmartMap map[string]DnsSmartInput

func (DnsSmartMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DnsSmart)(nil)).Elem()
}

func (i DnsSmartMap) ToDnsSmartMapOutput() DnsSmartMapOutput {
	return i.ToDnsSmartMapOutputWithContext(context.Background())
}

func (i DnsSmartMap) ToDnsSmartMapOutputWithContext(ctx context.Context) DnsSmartMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DnsSmartMapOutput)
}

type DnsSmartOutput struct{ *pulumi.OutputState }

func (DnsSmartOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DnsSmart)(nil)).Elem()
}

func (o DnsSmartOutput) ToDnsSmartOutput() DnsSmartOutput {
	return o
}

func (o DnsSmartOutput) ToDnsSmartOutputWithContext(ctx context.Context) DnsSmartOutput {
	return o
}

// A list of network prefixes allowed to query the DNS server (named ACL(s) are not supported using this provider).  Use '!' to negate an entry.
func (o DnsSmartOutput) AllowQueries() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *DnsSmart) pulumi.StringArrayOutput { return v.AllowQueries }).(pulumi.StringArrayOutput)
}

// A list of network prefixes allowed to query the DNS server for recursion (named ACL(s) are not supported using this provider).  Use '!' to negate an entry.
func (o DnsSmartOutput) AllowRecursions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *DnsSmart) pulumi.StringArrayOutput { return v.AllowRecursions }).(pulumi.StringArrayOutput)
}

// A list of network prefixes allowed to query the DNS erver for zone transfert (named ACL(s) are not supported using this provider).  Use '!' to negate an entry.
func (o DnsSmartOutput) AllowTransfers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *DnsSmart) pulumi.StringArrayOutput { return v.AllowTransfers }).(pulumi.StringArrayOutput)
}

// The DNS SMART architecture (Suported: multimaster, masterslave, single; Default: masterslave).
func (o DnsSmartOutput) Arch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DnsSmart) pulumi.StringPtrOutput { return v.Arch }).(pulumi.StringPtrOutput)
}

// The class associated to the DNS SMART.
func (o DnsSmartOutput) Class() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DnsSmart) pulumi.StringPtrOutput { return v.Class }).(pulumi.StringPtrOutput)
}

// The class parameters associated to the DNS SMART.
func (o DnsSmartOutput) ClassParameters() pulumi.StringMapOutput {
	return o.ApplyT(func(v *DnsSmart) pulumi.StringMapOutput { return v.ClassParameters }).(pulumi.StringMapOutput)
}

// Custom information about the DNS SMART.
func (o DnsSmartOutput) Comment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DnsSmart) pulumi.StringPtrOutput { return v.Comment }).(pulumi.StringPtrOutput)
}

// The forwarding mode of the DNS SMART (Supported: none, first, only; Default: none).
func (o DnsSmartOutput) Forward() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DnsSmart) pulumi.StringPtrOutput { return v.Forward }).(pulumi.StringPtrOutput)
}

// The IP address list of the forwarder(s) configured to configure on the DNS SMART.
func (o DnsSmartOutput) Forwarders() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *DnsSmart) pulumi.StringArrayOutput { return v.Forwarders }).(pulumi.StringArrayOutput)
}

// The name of the DNS SMART members.
func (o DnsSmartOutput) Members() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *DnsSmart) pulumi.StringArrayOutput { return v.Members }).(pulumi.StringArrayOutput)
}

// The name of the DNS SMART to create.
func (o DnsSmartOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *DnsSmart) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The recursion mode of the DNS SMART (Default: true).
func (o DnsSmartOutput) Recursion() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *DnsSmart) pulumi.BoolPtrOutput { return v.Recursion }).(pulumi.BoolPtrOutput)
}

type DnsSmartArrayOutput struct{ *pulumi.OutputState }

func (DnsSmartArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DnsSmart)(nil)).Elem()
}

func (o DnsSmartArrayOutput) ToDnsSmartArrayOutput() DnsSmartArrayOutput {
	return o
}

func (o DnsSmartArrayOutput) ToDnsSmartArrayOutputWithContext(ctx context.Context) DnsSmartArrayOutput {
	return o
}

func (o DnsSmartArrayOutput) Index(i pulumi.IntInput) DnsSmartOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *DnsSmart {
		return vs[0].([]*DnsSmart)[vs[1].(int)]
	}).(DnsSmartOutput)
}

type DnsSmartMapOutput struct{ *pulumi.OutputState }

func (DnsSmartMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DnsSmart)(nil)).Elem()
}

func (o DnsSmartMapOutput) ToDnsSmartMapOutput() DnsSmartMapOutput {
	return o
}

func (o DnsSmartMapOutput) ToDnsSmartMapOutputWithContext(ctx context.Context) DnsSmartMapOutput {
	return o
}

func (o DnsSmartMapOutput) MapIndex(k pulumi.StringInput) DnsSmartOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *DnsSmart {
		return vs[0].(map[string]*DnsSmart)[vs[1].(string)]
	}).(DnsSmartOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*DnsSmartInput)(nil)).Elem(), &DnsSmart{})
	pulumi.RegisterInputType(reflect.TypeOf((*DnsSmartArrayInput)(nil)).Elem(), DnsSmartArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DnsSmartMapInput)(nil)).Elem(), DnsSmartMap{})
	pulumi.RegisterOutputType(DnsSmartOutput{})
	pulumi.RegisterOutputType(DnsSmartArrayOutput{})
	pulumi.RegisterOutputType(DnsSmartMapOutput{})
}
