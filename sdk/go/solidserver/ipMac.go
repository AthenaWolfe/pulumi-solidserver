// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package solidserver

import (
	"context"
	"reflect"

	"errors"
	"github.com/AthenaWolfe/pulumi-solidserver/sdk/go/solidserver/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// IP MAC resource allows to map an IP address with a MAC address.
// It does not reflect any object within SOLIDserver, it is useful when provisioning
// IP addresses for VM(s) for which the MAC address is unknown until deployed.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/AthenaWolfe/pulumi-solidserver/sdk/go/solidserver"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := solidserver.NewIpMac(ctx, "myFirstIPMacAassoc", &solidserver.IpMacArgs{
//				Address: pulumi.Any(solidserver_ip_address.MyFirstIPAddress.Address),
//				Mac:     pulumi.String("00:11:22:33:44:55"),
//				Space:   pulumi.Any(solidserver_ip_space.MyFirstSpace.Name),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type IpMac struct {
	pulumi.CustomResourceState

	// The IP address to map with the MAC address.
	Address pulumi.StringOutput `pulumi:"address"`
	// The MAC Address o map with the IP address.
	Mac pulumi.StringOutput `pulumi:"mac"`
	// The name of the space into which mapping the IP and the MAC address.
	Space pulumi.StringOutput `pulumi:"space"`
}

// NewIpMac registers a new resource with the given unique name, arguments, and options.
func NewIpMac(ctx *pulumi.Context,
	name string, args *IpMacArgs, opts ...pulumi.ResourceOption) (*IpMac, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Address == nil {
		return nil, errors.New("invalid value for required argument 'Address'")
	}
	if args.Mac == nil {
		return nil, errors.New("invalid value for required argument 'Mac'")
	}
	if args.Space == nil {
		return nil, errors.New("invalid value for required argument 'Space'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource IpMac
	err := ctx.RegisterResource("solidserver:index/ipMac:IpMac", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetIpMac gets an existing IpMac resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetIpMac(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *IpMacState, opts ...pulumi.ResourceOption) (*IpMac, error) {
	var resource IpMac
	err := ctx.ReadResource("solidserver:index/ipMac:IpMac", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering IpMac resources.
type ipMacState struct {
	// The IP address to map with the MAC address.
	Address *string `pulumi:"address"`
	// The MAC Address o map with the IP address.
	Mac *string `pulumi:"mac"`
	// The name of the space into which mapping the IP and the MAC address.
	Space *string `pulumi:"space"`
}

type IpMacState struct {
	// The IP address to map with the MAC address.
	Address pulumi.StringPtrInput
	// The MAC Address o map with the IP address.
	Mac pulumi.StringPtrInput
	// The name of the space into which mapping the IP and the MAC address.
	Space pulumi.StringPtrInput
}

func (IpMacState) ElementType() reflect.Type {
	return reflect.TypeOf((*ipMacState)(nil)).Elem()
}

type ipMacArgs struct {
	// The IP address to map with the MAC address.
	Address string `pulumi:"address"`
	// The MAC Address o map with the IP address.
	Mac string `pulumi:"mac"`
	// The name of the space into which mapping the IP and the MAC address.
	Space string `pulumi:"space"`
}

// The set of arguments for constructing a IpMac resource.
type IpMacArgs struct {
	// The IP address to map with the MAC address.
	Address pulumi.StringInput
	// The MAC Address o map with the IP address.
	Mac pulumi.StringInput
	// The name of the space into which mapping the IP and the MAC address.
	Space pulumi.StringInput
}

func (IpMacArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ipMacArgs)(nil)).Elem()
}

type IpMacInput interface {
	pulumi.Input

	ToIpMacOutput() IpMacOutput
	ToIpMacOutputWithContext(ctx context.Context) IpMacOutput
}

func (*IpMac) ElementType() reflect.Type {
	return reflect.TypeOf((**IpMac)(nil)).Elem()
}

func (i *IpMac) ToIpMacOutput() IpMacOutput {
	return i.ToIpMacOutputWithContext(context.Background())
}

func (i *IpMac) ToIpMacOutputWithContext(ctx context.Context) IpMacOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IpMacOutput)
}

// IpMacArrayInput is an input type that accepts IpMacArray and IpMacArrayOutput values.
// You can construct a concrete instance of `IpMacArrayInput` via:
//
//	IpMacArray{ IpMacArgs{...} }
type IpMacArrayInput interface {
	pulumi.Input

	ToIpMacArrayOutput() IpMacArrayOutput
	ToIpMacArrayOutputWithContext(context.Context) IpMacArrayOutput
}

type IpMacArray []IpMacInput

func (IpMacArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*IpMac)(nil)).Elem()
}

func (i IpMacArray) ToIpMacArrayOutput() IpMacArrayOutput {
	return i.ToIpMacArrayOutputWithContext(context.Background())
}

func (i IpMacArray) ToIpMacArrayOutputWithContext(ctx context.Context) IpMacArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IpMacArrayOutput)
}

// IpMacMapInput is an input type that accepts IpMacMap and IpMacMapOutput values.
// You can construct a concrete instance of `IpMacMapInput` via:
//
//	IpMacMap{ "key": IpMacArgs{...} }
type IpMacMapInput interface {
	pulumi.Input

	ToIpMacMapOutput() IpMacMapOutput
	ToIpMacMapOutputWithContext(context.Context) IpMacMapOutput
}

type IpMacMap map[string]IpMacInput

func (IpMacMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*IpMac)(nil)).Elem()
}

func (i IpMacMap) ToIpMacMapOutput() IpMacMapOutput {
	return i.ToIpMacMapOutputWithContext(context.Background())
}

func (i IpMacMap) ToIpMacMapOutputWithContext(ctx context.Context) IpMacMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IpMacMapOutput)
}

type IpMacOutput struct{ *pulumi.OutputState }

func (IpMacOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IpMac)(nil)).Elem()
}

func (o IpMacOutput) ToIpMacOutput() IpMacOutput {
	return o
}

func (o IpMacOutput) ToIpMacOutputWithContext(ctx context.Context) IpMacOutput {
	return o
}

// The IP address to map with the MAC address.
func (o IpMacOutput) Address() pulumi.StringOutput {
	return o.ApplyT(func(v *IpMac) pulumi.StringOutput { return v.Address }).(pulumi.StringOutput)
}

// The MAC Address o map with the IP address.
func (o IpMacOutput) Mac() pulumi.StringOutput {
	return o.ApplyT(func(v *IpMac) pulumi.StringOutput { return v.Mac }).(pulumi.StringOutput)
}

// The name of the space into which mapping the IP and the MAC address.
func (o IpMacOutput) Space() pulumi.StringOutput {
	return o.ApplyT(func(v *IpMac) pulumi.StringOutput { return v.Space }).(pulumi.StringOutput)
}

type IpMacArrayOutput struct{ *pulumi.OutputState }

func (IpMacArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*IpMac)(nil)).Elem()
}

func (o IpMacArrayOutput) ToIpMacArrayOutput() IpMacArrayOutput {
	return o
}

func (o IpMacArrayOutput) ToIpMacArrayOutputWithContext(ctx context.Context) IpMacArrayOutput {
	return o
}

func (o IpMacArrayOutput) Index(i pulumi.IntInput) IpMacOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *IpMac {
		return vs[0].([]*IpMac)[vs[1].(int)]
	}).(IpMacOutput)
}

type IpMacMapOutput struct{ *pulumi.OutputState }

func (IpMacMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*IpMac)(nil)).Elem()
}

func (o IpMacMapOutput) ToIpMacMapOutput() IpMacMapOutput {
	return o
}

func (o IpMacMapOutput) ToIpMacMapOutputWithContext(ctx context.Context) IpMacMapOutput {
	return o
}

func (o IpMacMapOutput) MapIndex(k pulumi.StringInput) IpMacOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *IpMac {
		return vs[0].(map[string]*IpMac)[vs[1].(string)]
	}).(IpMacOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*IpMacInput)(nil)).Elem(), &IpMac{})
	pulumi.RegisterInputType(reflect.TypeOf((*IpMacArrayInput)(nil)).Elem(), IpMacArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*IpMacMapInput)(nil)).Elem(), IpMacMap{})
	pulumi.RegisterOutputType(IpMacOutput{})
	pulumi.RegisterOutputType(IpMacArrayOutput{})
	pulumi.RegisterOutputType(IpMacMapOutput{})
}
